Index: pkg/modbus/device/twindata.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\nCopyright 2020 The KubeEdge Authors.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n   http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\npackage device\r\n\r\nimport (\r\n\t\"fmt\"\r\n\t\"strconv\"\r\n\t\"strings\"\r\n\r\n\t\"github.com/kubeedge/mappers-go/pkg/common\"\r\n\t\"github.com/kubeedge/mappers-go/pkg/modbus/driver\"\r\n\t\"github.com/kubeedge/mappers-go/pkg/modbus/globals\"\r\n\t\"k8s.io/klog\"\r\n)\r\n\r\n// TwinData is the timer structure for getting twin/data.\r\ntype TwinData struct {\r\n\tClient             *driver.ModbusClient\r\n\tName               string\r\n\tType               string\r\n\tRegisterType       string\r\n\tAddress            uint16\r\n\tQuantity           uint16\r\n\tResults            []byte\r\n\tTopic              string\r\n\tDeviceModel        string\r\n\tDeviceInstanceName string\r\n}\r\n\r\n// Run timer function.\r\nfunc (td *TwinData) Run() error {\r\n\tvar (\r\n\t\terr error\r\n\t)\r\n\ttd.Results, err = td.Client.Get(td.RegisterType, td.Address, td.Quantity)\r\n\t// 访问失败之后，继续访问，访问10次，如果10次全部失败说明设备或者串口不可用，直接retuen\r\n\tif err != nil {\r\n\t\tfor i := 0; i <= 9; i++ {\r\n\t\t\tif td.Results, err = td.Client.Get(td.RegisterType, td.Address, td.Quantity); err == nil {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t\tif i == 9 {\r\n\t\t\t\treturn fmt.Errorf(\"IMU设备不可用\")\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\ts1 := strings.Replace(fmt.Sprintf(\"%v\", td.Results), \"[\", \"\", -1)\r\n\ts2 := strings.Replace(s1, \"]\", \"\", -1)\r\n\tsplitS2 := strings.Split(s2, \"\")\r\n\tvar nodeName string\r\n\tif len(strings.Split(td.DeviceInstanceName, \"-\")) == 3 && strings.Split(td.DeviceInstanceName, \"-\")[2] != \"\" {\r\n\t\tnodeName = strings.Split(td.DeviceInstanceName, \"-\")[2]\r\n\t}\r\n\t// acceleration\r\n\tss1 := splitS2[0]\r\n\tss2 := splitS2[1]\r\n\tss3 := splitS2[2]\r\n\tss4 := splitS2[3]\r\n\tss5 := splitS2[4]\r\n\tss6 := splitS2[5]\r\n\taxh, _ := strconv.Atoi(ss1)\r\n\taxl, _ := strconv.Atoi(ss2)\r\n\tayh, _ := strconv.Atoi(ss3)\r\n\tayl, _ := strconv.Atoi(ss4)\r\n\tazh, _ := strconv.Atoi(ss5)\r\n\tazl, _ := strconv.Atoi(ss6)\r\n\tk := 16.0\r\n\taccX := float64(axh<<8|axl) / 32768.0 * k\r\n\taccY := float64(ayh<<8|ayl) / 32768.0 * k\r\n\taccZ := float64(azh<<8|azl) / 32768.0 * k\r\n\tif accX >= k {\r\n\t\taccX -= 2 * k\r\n\t}\r\n\tif accY >= k {\r\n\t\taccY -= 2 * k\r\n\t}\r\n\tif accZ >= k {\r\n\t\taccZ -= 2 * k\r\n\t}\r\n\tklog.V(2).Info(\"---------accX-----------\", accX)\r\n\tklog.V(2).Info(\"---------accY-----------\", accY)\r\n\tklog.V(2).Info(\"---------accZ-----------\", accZ)\r\n\t// angularVelocity\r\n\r\n\tss7 := splitS2[6]\r\n\tss8 := splitS2[7]\r\n\tss9 := splitS2[8]\r\n\tss10 := splitS2[9]\r\n\tss11 := splitS2[10]\r\n\tss12 := splitS2[11]\r\n\twxh, _ := strconv.Atoi(ss7)\r\n\twxl, _ := strconv.Atoi(ss8)\r\n\twyh, _ := strconv.Atoi(ss9)\r\n\twyl, _ := strconv.Atoi(ss10)\r\n\twzh, _ := strconv.Atoi(ss11)\r\n\twzl, _ := strconv.Atoi(ss12)\r\n\tk = 2000.0\r\n\twX := float64(wxh<<8|wxl) / 32768.0 * k\r\n\twY := float64(wyh<<8|wyl) / 32768.0 * k\r\n\twZ := float64(wzh<<8|wzl) / 32768.0 * k\r\n\tif wX >= k {\r\n\t\twX -= 2 * k\r\n\t}\r\n\tif wY >= k {\r\n\t\twY -= 2 * k\r\n\t}\r\n\tif wZ >= k {\r\n\t\twZ -= 2 * k\r\n\t}\r\n\tklog.V(2).Info(\"---------wX-----------\", wX)\r\n\tklog.V(2).Info(\"---------wY-----------\", wY)\r\n\tklog.V(2).Info(\"---------wZ-----------\", wZ)\r\n\t// magnetic\r\n\tss13 := splitS2[12]\r\n\tss14 := splitS2[13]\r\n\tss15 := splitS2[14]\r\n\tss16 := splitS2[15]\r\n\tss17 := splitS2[16]\r\n\tss18 := splitS2[17]\r\n\thxH, _ := strconv.Atoi(ss13)\r\n\thxL, _ := strconv.Atoi(ss14)\r\n\thyH, _ := strconv.Atoi(ss15)\r\n\thyL, _ := strconv.Atoi(ss16)\r\n\thzH, _ := strconv.Atoi(ss17)\r\n\thzL, _ := strconv.Atoi(ss18)\r\n\tk = 1.0\r\n\thX := float64(hxH<<8 | hxL)\r\n\thY := float64(hyH<<8 | hyL)\r\n\thZ := float64(hzH<<8 | hzL)\r\n\tif hX >= k {\r\n\t\thX -= 2 * k\r\n\t}\r\n\tif hY >= k {\r\n\t\thY -= 2 * k\r\n\t}\r\n\tif hZ >= k {\r\n\t\thZ -= 2 * k\r\n\t}\r\n\tklog.V(2).Info(\"---------hX-----------\", hX)\r\n\tklog.V(2).Info(\"---------hY-----------\", hY)\r\n\tklog.V(2).Info(\"---------hZ-----------\", hZ)\r\n\t// angular\r\n\tss19 := splitS2[18]\r\n\tss20 := splitS2[19]\r\n\tss21 := splitS2[20]\r\n\tss22 := splitS2[21]\r\n\tss23 := splitS2[22]\r\n\tss24 := splitS2[23]\r\n\trollH, _ := strconv.Atoi(ss19)\r\n\trollL, _ := strconv.Atoi(ss20)\r\n\tpitchH, _ := strconv.Atoi(ss21)\r\n\tpitchL, _ := strconv.Atoi(ss22)\r\n\tyawH, _ := strconv.Atoi(ss23)\r\n\tYawL, _ := strconv.Atoi(ss24)\r\n\tk = 180.0\r\n\troll := float64(rollH<<8|rollL) / 32768.0 * k\r\n\tpitch := float64(pitchH<<8|pitchL) / 32768.0 * k\r\n\tyaw := float64(yawH<<8|YawL) / 32768.0 * k\r\n\tif roll >= k {\r\n\t\troll -= 2 * k\r\n\t}\r\n\tif pitch >= k {\r\n\t\tpitch -= 2 * k\r\n\t}\r\n\tif yaw >= k {\r\n\t\tyaw -= 2 * k\r\n\t}\r\n\tklog.V(2).Info(\"---------roll-----------\", roll)\r\n\tklog.V(2).Info(\"---------pitch-----------\", pitch)\r\n\tklog.V(2).Info(\"---------yaw-----------\", yaw)\r\n\r\n\t//element\r\n\tss25 := splitS2[len(splitS2)-8]\r\n\tss26 := splitS2[len(splitS2)-7]\r\n\tss27 := splitS2[len(splitS2)-6]\r\n\tss28 := splitS2[len(splitS2)-5]\r\n\tss29 := splitS2[len(splitS2)-4]\r\n\tss30 := splitS2[len(splitS2)-3]\r\n\tss31 := splitS2[len(splitS2)-2]\r\n\tss32 := splitS2[len(splitS2)-1]\r\n\tq0H, _ := strconv.Atoi(ss25)\r\n\tq0L, _ := strconv.Atoi(ss26)\r\n\tq1H, _ := strconv.Atoi(ss27)\r\n\tq1L, _ := strconv.Atoi(ss28)\r\n\tq2H, _ := strconv.Atoi(ss29)\r\n\tq2L, _ := strconv.Atoi(ss30)\r\n\tq3H, _ := strconv.Atoi(ss31)\r\n\tq3L, _ := strconv.Atoi(ss32)\r\n\tk = 1.0\r\n\tq0 := float64(q0H<<8|q0L) / 32768.0\r\n\tq1 := float64(q1H<<8|q1L) / 32768.0\r\n\tq2 := float64(q2H<<8|q2L) / 32768.0\r\n\tq3 := float64(q3H<<8|q3L) / 32768.0\r\n\tif q0 >= k {\r\n\t\tq0 -= 2 * k\r\n\t}\r\n\tif q1 >= k {\r\n\t\tq1 -= 2 * k\r\n\t}\r\n\tif q2 >= k {\r\n\t\tq2 -= 2 * k\r\n\t}\r\n\tif q3 >= k {\r\n\t\tq3 -= 2 * k\r\n\t}\r\n\tklog.V(2).Info(\"---------q0-----------\", q0)\r\n\tklog.V(2).Info(\"---------q1-----------\", q1)\r\n\tklog.V(2).Info(\"---------q2-----------\", q2)\r\n\tklog.V(2).Info(\"---------q3-----------\", q3)\r\n\tglobals.FBClient.Publish(td.DeviceInstanceName, fmt.Sprintf(`{\"node\":\"%s\",\"__name__\":\"%s\",\"accX\":%f,\"accY\":%f,\"accZ\":%f,\"wX\":%f,\"wY\":%f,\"wZ\":%f,\"Hx\":%f,\"Hy\":%f,\"Hz\":%f,\"Roll\":%f,\"Pitch\":%f,\"Yaw\":%f,\"Q0\":%f,\"Q1\":%f,\"Q2\":%f,\"Q3\":%f,\"state\":\"%s\",\"device\":\"imu\",\"topicKey\":\"%s\"}`, nodeName, td.DeviceInstanceName, accX, accY, accZ, wX, wY, wZ, hX, hY, hZ, roll, pitch, yaw, q0, q1, q2, q3, td.Client.GetStatus(), globals.TopicKey))\r\n\t// construct payload\r\n\tvar payload []byte\r\n\tif strings.Contains(td.Topic, \"$hw\") {\r\n\t\tif payload, err = common.CreateMessageTwinUpdate(td.Name, td.Type, strconv.Itoa(int(td.Results[0]))); err != nil {\r\n\t\t\tklog.Error(\"Create message twin update failed\")\r\n\t\t\treturn err\r\n\t\t}\r\n\t} else {\r\n\t\tif payload, err = common.CreateMessageData(td.Name, td.Type, strconv.Itoa(int(td.Results[0]))); err != nil {\r\n\t\t\tklog.Error(\"Create message data failed\")\r\n\t\t\treturn err\r\n\t\t}\r\n\t}\r\n\tif err = globals.MqttClient.Publish(td.Topic, payload); err != nil {\r\n\t\tklog.Error(err)\r\n\t}\r\n\r\n\tklog.V(2).Infof(\"Update value: %s, topic: %s\", strconv.Itoa(int(td.Results[0])), td.Topic)\r\n\treturn err\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- pkg/modbus/device/twindata.go	(revision 3ce8b648349f2f4f0c4d74cabf91d014cc88bcbd)
+++ pkg/modbus/device/twindata.go	(date 1621310386988)
@@ -20,6 +20,7 @@
 	"fmt"
 	"strconv"
 	"strings"
+	"time"
 
 	"github.com/kubeedge/mappers-go/pkg/common"
 	"github.com/kubeedge/mappers-go/pkg/modbus/driver"
@@ -45,6 +46,7 @@
 func (td *TwinData) Run() error {
 	var (
 		err error
+		currenttime time.Time
 	)
 	td.Results, err = td.Client.Get(td.RegisterType, td.Address, td.Quantity)
 	// 访问失败之后，继续访问，访问10次，如果10次全部失败说明设备或者串口不可用，直接retuen
@@ -58,6 +60,7 @@
 			}
 		}
 	}
+	currenttime =time.Now()
 	s1 := strings.Replace(fmt.Sprintf("%v", td.Results), "[", "", -1)
 	s2 := strings.Replace(s1, "]", "", -1)
 	splitS2 := strings.Split(s2, "")
@@ -65,19 +68,48 @@
 	if len(strings.Split(td.DeviceInstanceName, "-")) == 3 && strings.Split(td.DeviceInstanceName, "-")[2] != "" {
 		nodeName = strings.Split(td.DeviceInstanceName, "-")[2]
 	}
+	//currenttime
+	//time
+	ss0 := splitS2[0]
+	ss1 := splitS2[1]
+	ss2 := splitS2[2]
+	ss3 := splitS2[3]
+	ss4 := splitS2[4]
+	ss5 := splitS2[5]
+	ss6 := splitS2[6]
+	ss7 := splitS2[7]
+
+	year, _ := strconv.Atoi(ss0)
+	month, _ := strconv.Atoi(ss1)
+	day, _ := strconv.Atoi(ss2)
+	hour, _ := strconv.Atoi(ss3)
+	minute, _ := strconv.Atoi(ss4)
+	second, _ := strconv.Atoi(ss5)
+	millsecond1, _ := strconv.Atoi(ss6)
+	millsecond2, _ := strconv.Atoi(ss7)
+
+	klog.V(2).Info("---------year-----------", year,",",ss0)
+	klog.V(2).Info("---------month-----------", month,",",ss1)
+	klog.V(2).Info("---------day-----------", day,",",ss2)
+	klog.V(2).Info("---------hour-----------", hour,",",ss3)
+	klog.V(2).Info("---------minute-----------", minute,",",ss4)
+	klog.V(2).Info("---------second-----------", second,",",ss5)
+	klog.V(2).Info("---------millsecond1-----------", millsecond1,",",ss6)
+	klog.V(2).Info("---------millsecond2-----------", millsecond2,",",ss7)
+	klog.V(2).Info("---------currenttime-----------", currenttime)
 	// acceleration
-	ss1 := splitS2[0]
-	ss2 := splitS2[1]
-	ss3 := splitS2[2]
-	ss4 := splitS2[3]
-	ss5 := splitS2[4]
-	ss6 := splitS2[5]
-	axh, _ := strconv.Atoi(ss1)
-	axl, _ := strconv.Atoi(ss2)
-	ayh, _ := strconv.Atoi(ss3)
-	ayl, _ := strconv.Atoi(ss4)
-	azh, _ := strconv.Atoi(ss5)
-	azl, _ := strconv.Atoi(ss6)
+	ss8 := splitS2[8]
+	ss9 := splitS2[9]
+	ss10 := splitS2[10]
+	ss11 := splitS2[11]
+	ss12 := splitS2[12]
+	ss13 := splitS2[13]
+	axh, _ := strconv.Atoi(ss8)
+	axl, _ := strconv.Atoi(ss9)
+	ayh, _ := strconv.Atoi(ss10)
+	ayl, _ := strconv.Atoi(ss11)
+	azh, _ := strconv.Atoi(ss12)
+	azl, _ := strconv.Atoi(ss13)
 	k := 16.0
 	accX := float64(axh<<8|axl) / 32768.0 * k
 	accY := float64(ayh<<8|ayl) / 32768.0 * k
@@ -96,18 +128,18 @@
 	klog.V(2).Info("---------accZ-----------", accZ)
 	// angularVelocity
 
-	ss7 := splitS2[6]
-	ss8 := splitS2[7]
-	ss9 := splitS2[8]
-	ss10 := splitS2[9]
-	ss11 := splitS2[10]
-	ss12 := splitS2[11]
-	wxh, _ := strconv.Atoi(ss7)
-	wxl, _ := strconv.Atoi(ss8)
-	wyh, _ := strconv.Atoi(ss9)
-	wyl, _ := strconv.Atoi(ss10)
-	wzh, _ := strconv.Atoi(ss11)
-	wzl, _ := strconv.Atoi(ss12)
+	ss14 := splitS2[14]
+	ss15 := splitS2[15]
+	ss16 := splitS2[16]
+	ss17 := splitS2[17]
+	ss18 := splitS2[18]
+	ss19 := splitS2[19]
+	wxh, _ := strconv.Atoi(ss14)
+	wxl, _ := strconv.Atoi(ss15)
+	wyh, _ := strconv.Atoi(ss16)
+	wyl, _ := strconv.Atoi(ss17)
+	wzh, _ := strconv.Atoi(ss18)
+	wzl, _ := strconv.Atoi(ss19)
 	k = 2000.0
 	wX := float64(wxh<<8|wxl) / 32768.0 * k
 	wY := float64(wyh<<8|wyl) / 32768.0 * k
@@ -125,18 +157,18 @@
 	klog.V(2).Info("---------wY-----------", wY)
 	klog.V(2).Info("---------wZ-----------", wZ)
 	// magnetic
-	ss13 := splitS2[12]
-	ss14 := splitS2[13]
-	ss15 := splitS2[14]
-	ss16 := splitS2[15]
-	ss17 := splitS2[16]
-	ss18 := splitS2[17]
-	hxH, _ := strconv.Atoi(ss13)
-	hxL, _ := strconv.Atoi(ss14)
-	hyH, _ := strconv.Atoi(ss15)
-	hyL, _ := strconv.Atoi(ss16)
-	hzH, _ := strconv.Atoi(ss17)
-	hzL, _ := strconv.Atoi(ss18)
+	ss20 := splitS2[20]
+	ss21 := splitS2[21]
+	ss22 := splitS2[22]
+	ss23 := splitS2[23]
+	ss24 := splitS2[24]
+	ss25 := splitS2[25]
+	hxH, _ := strconv.Atoi(ss20)
+	hxL, _ := strconv.Atoi(ss21)
+	hyH, _ := strconv.Atoi(ss22)
+	hyL, _ := strconv.Atoi(ss23)
+	hzH, _ := strconv.Atoi(ss24)
+	hzL, _ := strconv.Atoi(ss25)
 	k = 1.0
 	hX := float64(hxH<<8 | hxL)
 	hY := float64(hyH<<8 | hyL)
@@ -154,18 +186,18 @@
 	klog.V(2).Info("---------hY-----------", hY)
 	klog.V(2).Info("---------hZ-----------", hZ)
 	// angular
-	ss19 := splitS2[18]
-	ss20 := splitS2[19]
-	ss21 := splitS2[20]
-	ss22 := splitS2[21]
-	ss23 := splitS2[22]
-	ss24 := splitS2[23]
-	rollH, _ := strconv.Atoi(ss19)
-	rollL, _ := strconv.Atoi(ss20)
-	pitchH, _ := strconv.Atoi(ss21)
-	pitchL, _ := strconv.Atoi(ss22)
-	yawH, _ := strconv.Atoi(ss23)
-	YawL, _ := strconv.Atoi(ss24)
+	ss26 := splitS2[26]
+	ss27 := splitS2[27]
+	ss28 := splitS2[28]
+	ss29 := splitS2[29]
+	ss30 := splitS2[30]
+	ss31 := splitS2[31]
+	rollH, _ := strconv.Atoi(ss26)
+	rollL, _ := strconv.Atoi(ss27)
+	pitchH, _ := strconv.Atoi(ss28)
+	pitchL, _ := strconv.Atoi(ss29)
+	yawH, _ := strconv.Atoi(ss30)
+	YawL, _ := strconv.Atoi(ss31)
 	k = 180.0
 	roll := float64(rollH<<8|rollL) / 32768.0 * k
 	pitch := float64(pitchH<<8|pitchL) / 32768.0 * k
@@ -184,22 +216,22 @@
 	klog.V(2).Info("---------yaw-----------", yaw)
 
 	//element
-	ss25 := splitS2[len(splitS2)-8]
-	ss26 := splitS2[len(splitS2)-7]
-	ss27 := splitS2[len(splitS2)-6]
-	ss28 := splitS2[len(splitS2)-5]
-	ss29 := splitS2[len(splitS2)-4]
-	ss30 := splitS2[len(splitS2)-3]
-	ss31 := splitS2[len(splitS2)-2]
-	ss32 := splitS2[len(splitS2)-1]
-	q0H, _ := strconv.Atoi(ss25)
-	q0L, _ := strconv.Atoi(ss26)
-	q1H, _ := strconv.Atoi(ss27)
-	q1L, _ := strconv.Atoi(ss28)
-	q2H, _ := strconv.Atoi(ss29)
-	q2L, _ := strconv.Atoi(ss30)
-	q3H, _ := strconv.Atoi(ss31)
-	q3L, _ := strconv.Atoi(ss32)
+	ss32 := splitS2[len(splitS2)-8]
+	ss33 := splitS2[len(splitS2)-7]
+	ss34 := splitS2[len(splitS2)-6]
+	ss35 := splitS2[len(splitS2)-5]
+	ss36 := splitS2[len(splitS2)-4]
+	ss37 := splitS2[len(splitS2)-3]
+	ss38 := splitS2[len(splitS2)-2]
+	ss39 := splitS2[len(splitS2)-1]
+	q0H, _ := strconv.Atoi(ss32)
+	q0L, _ := strconv.Atoi(ss33)
+	q1H, _ := strconv.Atoi(ss34)
+	q1L, _ := strconv.Atoi(ss35)
+	q2H, _ := strconv.Atoi(ss36)
+	q2L, _ := strconv.Atoi(ss37)
+	q3H, _ := strconv.Atoi(ss38)
+	q3L, _ := strconv.Atoi(ss39)
 	k = 1.0
 	q0 := float64(q0H<<8|q0L) / 32768.0
 	q1 := float64(q1H<<8|q1L) / 32768.0
@@ -221,6 +253,12 @@
 	klog.V(2).Info("---------q1-----------", q1)
 	klog.V(2).Info("---------q2-----------", q2)
 	klog.V(2).Info("---------q3-----------", q3)
+
+
+
+
+
+
 	globals.FBClient.Publish(td.DeviceInstanceName, fmt.Sprintf(`{"node":"%s","__name__":"%s","accX":%f,"accY":%f,"accZ":%f,"wX":%f,"wY":%f,"wZ":%f,"Hx":%f,"Hy":%f,"Hz":%f,"Roll":%f,"Pitch":%f,"Yaw":%f,"Q0":%f,"Q1":%f,"Q2":%f,"Q3":%f,"state":"%s","device":"imu","topicKey":"%s"}`, nodeName, td.DeviceInstanceName, accX, accY, accZ, wX, wY, wZ, hX, hY, hZ, roll, pitch, yaw, q0, q1, q2, q3, td.Client.GetStatus(), globals.TopicKey))
 	// construct payload
 	var payload []byte
Index: pkg/modbus/device/device.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*\r\nCopyright 2020 The KubeEdge Authors.\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\n   http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n*/\r\n\r\npackage device\r\n\r\nimport (\r\n\t\"encoding/json\"\r\n\t\"errors\"\r\n\t\"fmt\"\r\n\t\"regexp\"\r\n\t\"strconv\"\r\n\t\"sync\"\r\n\t\"time\"\r\n\r\n\tmqtt \"github.com/eclipse/paho.mqtt.golang\"\r\n\t\"github.com/kubeedge/mappers-go/pkg/common\"\r\n\t\"github.com/kubeedge/mappers-go/pkg/modbus/configmap\"\r\n\t\"github.com/kubeedge/mappers-go/pkg/modbus/driver\"\r\n\t\"github.com/kubeedge/mappers-go/pkg/modbus/globals\"\r\n\t\"k8s.io/klog\"\r\n)\r\n\r\nvar devices map[string]*globals.ModbusDev\r\nvar models map[string]common.DeviceModel\r\nvar protocols map[string]common.Protocol\r\nvar wg sync.WaitGroup\r\n\r\n// setVisitor check if visitory is readonly, if not then set it.\r\nfunc setVisitor(visitorConfig *configmap.ModbusVisitorConfig, twin *common.Twin, client *driver.ModbusClient) {\r\n\tif twin.PVisitor.PProperty.AccessMode == \"ReadOnly\" {\r\n\t\tklog.V(1).Info(\"Visit readonly register: \", visitorConfig.Offset)\r\n\t\treturn\r\n\t}\r\n\r\n\tklog.V(2).Infof(\"Convert type: %s, value: %s \", twin.PVisitor.PProperty.DataType, twin.Desired.Value)\r\n\tvalue, err := common.Convert(twin.PVisitor.PProperty.DataType, twin.Desired.Value)\r\n\tif err != nil {\r\n\t\tklog.Error(err)\r\n\t\treturn\r\n\t}\r\n\r\n\tvalueInt, _ := value.(int64)\r\n\t_, err = client.Set(visitorConfig.Register, visitorConfig.Offset, uint16(valueInt))\r\n\tif err != nil {\r\n\t\tklog.Error(err, visitorConfig)\r\n\t\treturn\r\n\t}\r\n}\r\n\r\n// getDeviceID extract the device ID from Mqtt topic.\r\nfunc getDeviceID(topic string) (id string) {\r\n\tre := regexp.MustCompile(`hw/events/device/(.+)/twin/update/delta`)\r\n\treturn re.FindStringSubmatch(topic)[1]\r\n}\r\n\r\n// onMessage callback function of Mqtt subscribe message.\r\nfunc onMessage(client mqtt.Client, message mqtt.Message) {\r\n\tklog.V(2).Info(\"Receive message\", message.Topic())\r\n\t// Get device ID and get device instance\r\n\tid := getDeviceID(message.Topic())\r\n\tif id == \"\" {\r\n\t\tklog.Error(\"Wrong topic\")\r\n\t\treturn\r\n\t}\r\n\tklog.V(2).Info(\"Device id: \", id)\r\n\r\n\tvar dev *globals.ModbusDev\r\n\tvar ok bool\r\n\tif dev, ok = devices[id]; !ok {\r\n\t\tklog.Error(\"Device not exist\")\r\n\t\treturn\r\n\t}\r\n\r\n\t// Get twin map key as the propertyName\r\n\tvar delta common.DeviceTwinDelta\r\n\tif err := json.Unmarshal(message.Payload(), &delta); err != nil {\r\n\t\tklog.Error(\"Unmarshal message failed: \", err)\r\n\t\treturn\r\n\t}\r\n\tfor twinName, twinValue := range delta.Delta {\r\n\t\ti := 0\r\n\t\tfor i = 0; i < len(dev.Instance.Twins); i++ {\r\n\t\t\tif twinName == dev.Instance.Twins[i].PropertyName {\r\n\t\t\t\tbreak\r\n\t\t\t}\r\n\t\t}\r\n\t\tif i == len(dev.Instance.Twins) {\r\n\t\t\tklog.Error(\"Twin not found: \", twinName)\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\t// Desired value is not changed.\r\n\t\tif dev.Instance.Twins[i].Desired.Value == twinValue {\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tdev.Instance.Twins[i].Desired.Value = twinValue\r\n\t\tvar visitorConfig configmap.ModbusVisitorConfig\r\n\t\tif err := json.Unmarshal([]byte(dev.Instance.Twins[i].PVisitor.VisitorConfig), &visitorConfig); err != nil {\r\n\t\t\tklog.Error(\"Unmarshal visitor config failed\")\r\n\t\t}\r\n\t\tsetVisitor(&visitorConfig, &dev.Instance.Twins[i], dev.ModbusClient)\r\n\t}\r\n}\r\n\r\n// isRS485Enabled is RS485 feature enabled for RTU.\r\nfunc isRS485Enabled(customizedValue configmap.CustomizedValue) bool {\r\n\tisEnabled := false\r\n\r\n\tif len(customizedValue) != 0 {\r\n\t\tif value, ok := customizedValue[\"serialType\"]; ok {\r\n\t\t\tif value == \"RS485\" {\r\n\t\t\t\tisEnabled = true\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn isEnabled\r\n}\r\n\r\n// initModbus initialize modbus client\r\nfunc initModbus(protocolConfig configmap.ModbusProtocolCommonConfig, slaveID int16) (client *driver.ModbusClient, err error) {\r\n\tif protocolConfig.COM.SerialPort != \"\" {\r\n\t\tmodbusRTU := driver.ModbusRTU{SlaveID: byte(slaveID),\r\n\t\t\tSerialName:   protocolConfig.COM.SerialPort,\r\n\t\t\tBaudRate:     int(protocolConfig.COM.BaudRate),\r\n\t\t\tDataBits:     int(protocolConfig.COM.DataBits),\r\n\t\t\tStopBits:     int(protocolConfig.COM.StopBits),\r\n\t\t\tParity:       protocolConfig.COM.Parity,\r\n\t\t\tRS485Enabled: isRS485Enabled(protocolConfig.CustomizedValues),\r\n\t\t\tTimeout:      5 * time.Second}\r\n\t\tclient, _ = driver.NewClient(modbusRTU)\r\n\t} else if protocolConfig.TCP.IP != \"\" {\r\n\t\tmodbusTCP := driver.ModbusTCP{\r\n\t\t\tSlaveID:  byte(slaveID),\r\n\t\t\tDeviceIP: protocolConfig.TCP.IP,\r\n\t\t\tTCPPort:  strconv.FormatInt(protocolConfig.TCP.Port, 10),\r\n\t\t\tTimeout:  5 * time.Second}\r\n\t\tclient, _ = driver.NewClient(modbusTCP)\r\n\t} else {\r\n\t\treturn nil, errors.New(\"No protocol found\")\r\n\t}\r\n\treturn client, nil\r\n}\r\n\r\n// initTwin initialize the timer to get twin value.\r\nfunc initTwin(dev *globals.ModbusDev) {\r\n\tfor i := 0; i < len(dev.Instance.Twins); i++ {\r\n\t\tvar visitorConfig configmap.ModbusVisitorConfig\r\n\t\tif err := json.Unmarshal([]byte(dev.Instance.Twins[i].PVisitor.VisitorConfig), &visitorConfig); err != nil {\r\n\t\t\tklog.Error(err)\r\n\t\t\tcontinue\r\n\t\t}\r\n\t\tsetVisitor(&visitorConfig, &dev.Instance.Twins[i], dev.ModbusClient)\r\n\r\n\t\ttwinData := TwinData{Client: dev.ModbusClient,\r\n\t\t\tName:               dev.Instance.Twins[i].PropertyName,\r\n\t\t\tType:               dev.Instance.Twins[i].Desired.Metadatas.Type,\r\n\t\t\tRegisterType:       visitorConfig.Register,\r\n\t\t\tAddress:            visitorConfig.Offset,\r\n\t\t\tQuantity:           uint16(visitorConfig.Limit),\r\n\t\t\tTopic:              fmt.Sprintf(common.TopicTwinUpdate, dev.Instance.ID),\r\n\t\t\tDeviceModel:        dev.Instance.Model,\r\n\t\t\tDeviceInstanceName: dev.Instance.Name}\r\n\t\tcollectCycle := time.Duration(dev.Instance.Twins[i].PVisitor.CollectCycle)\r\n\t\t// If the collect cycle is not set, set it to 1 second.\r\n\t\tif collectCycle == 0 {\r\n\t\t\tcollectCycle = 1 * time.Second\r\n\t\t}\r\n\t\ttimer := common.Timer{Function: twinData.Run, Duration: collectCycle, Times: 0}\r\n\t\twg.Add(1)\r\n\t\tgo func() {\r\n\t\t\tif err := timer.Start(); err != nil {\r\n\t\t\t\twg.Done()\r\n\t\t\t}\r\n\t\t}()\r\n\t}\r\n}\r\n\r\n// initData initialize the timer to get data.\r\nfunc initData(dev *globals.ModbusDev) {\r\n\tif dev.Instance.Model == \"modbus-rtu-imu-model\" {\r\n\t\tfor _, property := range dev.Instance.Datas.Properties {\r\n\t\t\tvar visitorConfig configmap.ModbusVisitorConfig\r\n\t\t\tif err := json.Unmarshal([]byte(property.PVisitor.VisitorConfig), &visitorConfig); err != nil {\r\n\t\t\t\tklog.Error(\"Unmarshal visitor config failed\")\r\n\t\t\t}\r\n\t\t}\r\n\t\ttwinData := TwinData{Client: dev.ModbusClient,\r\n\t\t\tName:               \"IMUALL\",\r\n\t\t\tType:               \"float\",\r\n\t\t\tRegisterType:       \"HoldingRegister\",\r\n\t\t\tAddress:            52,\r\n\t\t\tQuantity:           33,\r\n\t\t\tTopic:              fmt.Sprintf(common.TopicDataUpdate, dev.Instance.ID),\r\n\t\t\tDeviceModel:        dev.Instance.Model,\r\n\t\t\tDeviceInstanceName: dev.Instance.Name,\r\n\t\t}\r\n\t\tcollectCycle, _ := time.ParseDuration(\"0.01s\")\r\n\t\ttimer := common.Timer{Function: twinData.Run, Duration: collectCycle, Times: 0}\r\n\t\ttimer.Start()\r\n\t}\r\n}\r\n\r\n// initSubscribeMqtt subscribe Mqtt topics.\r\nfunc initSubscribeMqtt(instanceID string) error {\r\n\ttopic := fmt.Sprintf(common.TopicTwinUpdateDelta, instanceID)\r\n\tklog.V(1).Info(\"Subscribe topic: \", topic)\r\n\treturn globals.MqttClient.Subscribe(topic, onMessage)\r\n}\r\n\r\n// initGetStatus start timer to get device status and send to eventbus.\r\nfunc initGetStatus(dev *globals.ModbusDev) {\r\n\tgetStatus := GetStatus{Client: dev.ModbusClient,\r\n\t\ttopic: fmt.Sprintf(common.TopicStateUpdate, dev.Instance.ID)}\r\n\ttimer := common.Timer{Function: getStatus.Run, Duration: 1 * time.Second, Times: 0}\r\n\twg.Add(1)\r\n\tgo func() {\r\n\t\tdefer wg.Done()\r\n\t\ttimer.Start()\r\n\t}()\r\n}\r\n\r\n// start start the device.\r\nfunc start(dev *globals.ModbusDev) {\r\n\tvar protocolConfig configmap.ModbusProtocolCommonConfig\r\n\tif err := json.Unmarshal([]byte(dev.Instance.PProtocol.ProtocolCommonConfig), &protocolConfig); err != nil {\r\n\t\tklog.Error(err)\r\n\t\treturn\r\n\t}\r\n\r\n\tclient, err := initModbus(protocolConfig, dev.Instance.PProtocol.ProtocolConfigs.SlaveID)\r\n\tif err != nil {\r\n\t\tklog.Error(err)\r\n\t\treturn\r\n\t}\r\n\tdev.ModbusClient = client\r\n\r\n\tinitTwin(dev)\r\n\tinitData(dev)\r\n\r\n\tif err := initSubscribeMqtt(dev.Instance.ID); err != nil {\r\n\t\tklog.Error(err)\r\n\t\treturn\r\n\t}\r\n\r\n\tinitGetStatus(dev)\r\n}\r\n\r\n// DevInit initialize the device datas.\r\nfunc DevInit(configmapPath string) error {\r\n\tdevices = make(map[string]*globals.ModbusDev)\r\n\tmodels = make(map[string]common.DeviceModel)\r\n\tprotocols = make(map[string]common.Protocol)\r\n\treturn configmap.Parse(configmapPath, devices, models, protocols)\r\n}\r\n\r\n// DevStart start all devices.\r\nfunc DevStart() {\r\n\tfor id, dev := range devices {\r\n\t\tklog.V(4).Info(\"Dev: \", id, dev)\r\n\t\tstart(dev)\r\n\t}\r\n\twg.Wait()\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- pkg/modbus/device/device.go	(revision 3ce8b648349f2f4f0c4d74cabf91d014cc88bcbd)
+++ pkg/modbus/device/device.go	(date 1621309443619)
@@ -200,8 +200,8 @@
 			Name:               "IMUALL",
 			Type:               "float",
 			RegisterType:       "HoldingRegister",
-			Address:            52,
-			Quantity:           33,
+			Address:            48,
+			Quantity:           37,
 			Topic:              fmt.Sprintf(common.TopicDataUpdate, dev.Instance.ID),
 			DeviceModel:        dev.Instance.Model,
 			DeviceInstanceName: dev.Instance.Name,
